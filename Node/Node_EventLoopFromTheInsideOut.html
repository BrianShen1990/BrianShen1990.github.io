

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Node Event Loop From The Inside Out &mdash; KNWON Blog documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="KNWON Blog documentation" href="../index.html"/>
        <link rel="up" title="Node" href="Node.html"/>
        <link rel="next" title="Easy profiling for Node.js Applications" href="Node_Profiling.html"/>
        <link rel="prev" title="The Node.js Event Loop, Timers, and process.nextTick()" href="Node_EventLoop.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> KNWON
          

          
          </a>

          
            
            
              <div class="version">
                Blog
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Tools/Tools.html">Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Web/Web.html">Web</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="Node.html">Node</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Node_ES6.html">ES6 Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="Node_EventLoop.html">The Node.js Event Loop, Timers, and <code class="code docutils literal"><span class="pre">process.nextTick()</span></code></a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Node Event Loop From The Inside Out</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#linux-unix-programer">Linux/Unix Programer</a></li>
<li class="toctree-l3"><a class="reference internal" href="#what-is-node-event-loop">What is Node Event Loop?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#when-does-node-exit">When does Node exit?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#can-everything-be-async">can everything be async?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#details">Details</a></li>
<li class="toctree-l3"><a class="reference internal" href="#important-notes-about-the-uv-thread-pool">Important notes about the UV thread pool</a></li>
<li class="toctree-l3"><a class="reference internal" href="#linux-unix">Linux/Unix 程序员问题</a></li>
<li class="toctree-l3"><a class="reference internal" href="#node">什么是 Node 事件循环</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id1">Node什么时候退出？</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">所有事件都可以异步么？</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">详情</a></li>
<li class="toctree-l3"><a class="reference internal" href="#uv">关于 UV 进程池的重要信息</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Node_Profiling.html">Easy profiling for Node.js Applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="Node_Scheduler.html">Node Task Queue Research / Node 任务队列学习</a></li>
<li class="toctree-l2"><a class="reference internal" href="Node_Webpack.html">Node Webpack</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Python/Python.html">Python</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">KNWON</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="Node.html">Node</a> &raquo;</li>
      
    <li>Node Event Loop From The Inside Out</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/Node/Node_EventLoopFromTheInsideOut.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="node-event-loop-from-the-inside-out">
<h1><a class="toc-backref" href="#id4">Node Event Loop From The Inside Out</a><a class="headerlink" href="#node-event-loop-from-the-inside-out" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">date:</th><td class="field-body">2019-02-12</td>
</tr>
<tr class="field-even field"><th class="field-name">tags:</th><td class="field-body">Node, Event Loop</td>
</tr>
<tr class="field-odd field"><th class="field-name">category:</th><td class="field-body">Node</td>
</tr>
<tr class="field-even field"><th class="field-name">slug:</th><td class="field-body">Node_Event_Loop_From_The_Inside_Out</td>
</tr>
<tr class="field-odd field"><th class="field-name">author:</th><td class="field-body">Brian Shen</td>
</tr>
<tr class="field-even field"><th class="field-name">summary:</th><td class="field-body">Node Event Loop From The Inside Out</td>
</tr>
</tbody>
</table>
<div class="contents topic" id="contents">
<span id="node-event-loop-from-the-inside-out-rst"></span><p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#node-event-loop-from-the-inside-out" id="id4">Node Event Loop From The Inside Out</a><ul>
<li><a class="reference internal" href="#linux-unix-programer" id="id5">Linux/Unix Programer</a></li>
<li><a class="reference internal" href="#what-is-node-event-loop" id="id6">What is Node Event Loop?</a></li>
<li><a class="reference internal" href="#when-does-node-exit" id="id7">When does Node exit?</a></li>
<li><a class="reference internal" href="#can-everything-be-async" id="id8">can everything be async?</a></li>
<li><a class="reference internal" href="#details" id="id9">Details</a></li>
<li><a class="reference internal" href="#important-notes-about-the-uv-thread-pool" id="id10">Important notes about the UV thread pool</a></li>
<li><a class="reference internal" href="#linux-unix" id="id11">Linux/Unix 程序员问题</a></li>
<li><a class="reference internal" href="#node" id="id12">什么是 Node 事件循环</a></li>
<li><a class="reference internal" href="#id1" id="id13">Node什么时候退出？</a></li>
<li><a class="reference internal" href="#id2" id="id14">所有事件都可以异步么？</a></li>
<li><a class="reference internal" href="#id3" id="id15">详情</a></li>
<li><a class="reference internal" href="#uv" id="id16">关于 UV 进程池的重要信息</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="linux-unix-programer">
<h2><a class="toc-backref" href="#id5">Linux/Unix Programer</a><a class="headerlink" href="#linux-unix-programer" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p class="first">Scale Problem</p>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">server</span> <span class="o">=</span> <span class="n">socket</span><span class="p">();</span>
<span class="n">bind</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="mi">80</span><span class="p">);</span>
<span class="n">listen</span><span class="p">(</span><span class="n">server</span><span class="p">);</span>

<span class="k">while</span><span class="p">(</span><span class="kt">int</span> <span class="n">connection</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">server</span><span class="p">)){</span>
  <span class="n">pthread_create</span><span class="p">(</span><span class="n">echo</span><span class="p">,</span> <span class="n">connection</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">echo</span><span class="p">(</span><span class="kt">int</span> <span class="n">connection</span><span class="p">){</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>
  <span class="k">while</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">buf</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">write</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Old system can only handle about hundreds threads. So it doesn&#8217;t scale out.</p>
</li>
<li><p class="first">Scale solution: epoll - setup</p>
<p>epoll -&gt; Linux
KQ -&gt; Mac</p>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">server</span> <span class="o">=</span> <span class="p">..</span> <span class="c1">// like before</span>
<span class="kt">int</span> <span class="n">evetfd</span> <span class="o">=</span> <span class="n">epoll_create1</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">ev</span> <span class="o">=</span> <span class="p">(.</span><span class="n">event</span> <span class="o">=</span> <span class="n">EPOLLIN</span><span class="p">,</span> <span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">server</span><span class="p">);</span>
<span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">server</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ev</span><span class="p">);</span>

<span class="p">...</span>
<span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">events</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="k">while</span><span class="p">(</span> <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">epoll_wait</span><span class="p">(</span><span class="n">eventfd</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span> <span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span><span class="o">&lt;</span> <span class="n">max</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">events</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="p">.</span><span class="n">fd</span> <span class="o">==</span> <span class="n">server</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Server socket has connection!</span>
      <span class="kt">int</span> <span class="n">connection</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">server</span><span class="p">);</span>
      <span class="n">ev</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">EPOLLIN</span><span class="p">;</span>
      <span class="n">ev</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">connection</span><span class="p">;</span>
      <span class="n">epoll_ctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ev</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// connection socket has data</span>
      <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>
      <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">buf</span><span class="p">);</span>
      <span class="n">write</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="what-is-node-event-loop">
<h2><a class="toc-backref" href="#id6">What is Node Event Loop?</a><a class="headerlink" href="#what-is-node-event-loop" title="Permalink to this headline">¶</a></h2>
<p>A semi-infinite loop, polling and blocking on the O/S until in a set of file descriptors are ready.</p>
<p>Something interesting happened, and node will pass it to JavaScript.</p>
<ul class="simple">
<li>event</li>
<li>callback</li>
<li>fs thing</li>
</ul>
</div>
<div class="section" id="when-does-node-exit">
<h2><a class="toc-backref" href="#id7">When does Node exit?</a><a class="headerlink" href="#when-does-node-exit" title="Permalink to this headline">¶</a></h2>
<p>It exits when it no longer had any events to wait for, at which points the loop must complete.</p>
</div>
<div class="section" id="can-everything-be-async">
<h2><a class="toc-backref" href="#id8">can everything be async?</a><a class="headerlink" href="#can-everything-be-async" title="Permalink to this headline">¶</a></h2>
<p>Can we poll for all system activity Node.js wants to be notified of? In other words, can everything be async?</p>
<p>Yes and no? There are basically three cases of things:</p>
<ol class="arabic simple">
<li>Pollable file descriptors: can be directly waited on</li>
</ol>
<blockquote>
<div>sockets (net/dgram/http/tls/https/child_process pipes/stdin,out,err)
classic, well supported</div></blockquote>
<ol class="arabic simple" start="2">
<li>Time: next timeout can be directly wait on</li>
</ol>
<blockquote>
<div><p>(timeouts and intervals)
poll(..., int timeout)
kqueue(..., struct timespec * timeout)
epoll_wait(..., int timeout, ...)</p>
<p>timeout resolution is milliseconds, timespec is nanoseconds, but both are rounded up to system clock granularity.</p>
<p>Only one timeout at a time can be waited on, but Node.js keeps all timeout sorted, and sets the timeout value to the next one.</p>
</div></blockquote>
<ol class="arabic simple" start="3">
<li>Everything else: must happen off loop, and signal back to the loop when done.</li>
</ol>
</div>
<div class="section" id="details">
<h2><a class="toc-backref" href="#id9">Details</a><a class="headerlink" href="#details" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p class="first">Not pollable: file system</p>
<p>Everything in fs.* uses uv thread poll (unless they are sync).
The blocking call is made by a thread, and when it completes, readiness is signaled back to the event loop using either an eventfd or a self pipe.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">self-pipe:
A pipe, where one end is written to by a thread or a signal handler, and the other end is polled in the loop. Traditional way to &#8220;wake up&#8221; a polling loop when the event to wait for is not directly representable as a file descriptor.</p>
</div>
</li>
<li><p class="first">Sometimes pollable: dns</p>
<ul class="simple">
<li><code class="code docutils literal"><span class="pre">dns.lookup()</span></code> calls <code class="code docutils literal"><span class="pre">getaddrinfo()</span></code> , a function in the system resolver library that makes blocking socket calls and cannot be integrated into a polling loop. Like fs.*, it&#8217;s called in the thread pool.</li>
<li><code class="code docutils literal"><span class="pre">dns.&lt;everything</span> <span class="pre">else&gt;</span></code> calls functions in c-ares, a non-blocking DNS resolver, and integrates with the loop, not the thread poll.</li>
</ul>
<p>Docs bend over backwards to explain how these two differ, but now that you know that blocking library calls must be shunted off to the thread pool, whereas DNS queries use TCP/UDP and can integrate into the event loop, the distinction should be clear.</p>
</li>
<li><p class="first">Pollable: signals</p>
<p>The ultimate async... uses the self-pipe pattern to write the signal number to the loop.</p>
<p>Note that listening for signals doesn&#8217;t &#8220;ref&#8221; the event loop, which is consistent with signal usage as &#8220;probably won&#8217;t happen&#8221; IPC mechanism.</p>
</li>
<li><p class="first">Pollable: child processes</p>
<ul class="simple">
<li>Unix signals child process termination with SIGCHILD.</li>
<li>Pipes between the parent and child are pollable.</li>
</ul>
</li>
<li><p class="first">Sometimes pollable: C++ addons</p>
<p>Addons should use the UV thread pool or integrate with the loop, but can do anything, including making loop-blocking system calls (perhaps unintentionally).</p>
<p>Hints:</p>
<ul class="simple">
<li>Review addon code</li>
<li>Track loop metrics</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="important-notes-about-the-uv-thread-pool">
<h2><a class="toc-backref" href="#id10">Important notes about the UV thread pool</a><a class="headerlink" href="#important-notes-about-the-uv-thread-pool" title="Permalink to this headline">¶</a></h2>
<p>It is shared by:</p>
<blockquote>
<div><ul class="simple">
<li>fs</li>
<li>dns (only dns.lookup(), rest is fine)</li>
<li>crypto (only crypto.randomBytes() and crypto.pbkdf2())</li>
<li>http,get/request() (if called with a name, dns.lookup() is used)</li>
<li>any C++ addons that use it</li>
</ul>
</div></blockquote>
<p>Default number of threads is 4, significantly parallel users of the above should increase the size.</p>
<p>Hints:</p>
<ul class="simple">
<li>Resolve DNS names yourself, using the direct APIs to avoid dns.lookup(), and stay out of the thread pool</li>
<li>Increase the thread pool size with UV_THREADPOOL_SIZE</li>
</ul>
<p>You should now be able to describe:</p>
<ul class="simple">
<li>What is the event loop</li>
<li>When is node multi-threaded</li>
<li>Why it &#8220;scales well&#8221;</li>
</ul>
</div>
<div class="section" id="linux-unix">
<h2><a class="toc-backref" href="#id11">Linux/Unix 程序员问题</a><a class="headerlink" href="#linux-unix" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p class="first">扩展问题</p>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">server</span> <span class="o">=</span> <span class="n">socket</span><span class="p">();</span>
<span class="n">bind</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="mi">80</span><span class="p">);</span>
<span class="n">listen</span><span class="p">(</span><span class="n">server</span><span class="p">);</span>

<span class="k">while</span><span class="p">(</span><span class="kt">int</span> <span class="n">connection</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">server</span><span class="p">)){</span>
  <span class="n">pthread_create</span><span class="p">(</span><span class="n">echo</span><span class="p">,</span> <span class="n">connection</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">echo</span><span class="p">(</span><span class="kt">int</span> <span class="n">connection</span><span class="p">){</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>
  <span class="k">while</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">buf</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">write</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>像这样为每一个连接创建一个进程，非常的耗费系统资源。老旧的系统只能处理几百个进程，所以这样的设计思想是不能扩展的。</p>
</li>
<li><p class="first">扩展问题解决方案 epoll</p>
<p>epoll -&gt; Linux
KQ -&gt; Mac</p>
<div class="highlight-C"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">server</span> <span class="o">=</span> <span class="p">..</span> <span class="c1">// like before</span>
<span class="kt">int</span> <span class="n">evetfd</span> <span class="o">=</span> <span class="n">epoll_create1</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">ev</span> <span class="o">=</span> <span class="p">(.</span><span class="n">event</span> <span class="o">=</span> <span class="n">EPOLLIN</span><span class="p">,</span> <span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">server</span><span class="p">);</span>
<span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">server</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ev</span><span class="p">);</span>

<span class="p">...</span>
<span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">events</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="k">while</span><span class="p">(</span> <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">epoll_wait</span><span class="p">(</span><span class="n">eventfd</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span> <span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span><span class="o">&lt;</span> <span class="n">max</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">events</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="p">.</span><span class="n">fd</span> <span class="o">==</span> <span class="n">server</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Server socket has connection!</span>
      <span class="kt">int</span> <span class="n">connection</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">server</span><span class="p">);</span>
      <span class="n">ev</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">EPOLLIN</span><span class="p">;</span>
      <span class="n">ev</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">connection</span><span class="p">;</span>
      <span class="n">epoll_ctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ev</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// connection socket has data</span>
      <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>
      <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">buf</span><span class="p">);</span>
      <span class="n">write</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="node">
<h2><a class="toc-backref" href="#id12">什么是 Node 事件循环</a><a class="headerlink" href="#node" title="Permalink to this headline">¶</a></h2>
<p>一个近似无限的循环，轮询并且阻塞系统，直到一系列的文件句柄准备完成。</p>
<p>当一些Node感兴趣的事件发生时，Node会将这些事件转发给 JavaScript。</p>
<ul class="simple">
<li>事件</li>
<li>回调</li>
<li>文件操作相关</li>
</ul>
</div>
<div class="section" id="id1">
<h2><a class="toc-backref" href="#id13">Node什么时候退出？</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>当不在有等待的事件时，循环就完成了，不再继续执行。</p>
</div>
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id14">所有事件都可以异步么？</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>我们能够轮询所有Node想知道的系统活动么？所有的事件都可以是异步的么？</p>
<p>有的可以，有的不可以。基本来说，有 3 中事件：</p>
<ol class="arabic simple">
<li>可轮询的文件句柄：能够被直接等待</li>
</ol>
<blockquote>
<div>sockets (net/dgram/http/tls/https/child_process pipes/stdin,out,err)
经典的，支持的很好</div></blockquote>
<ol class="arabic simple" start="2">
<li>定时器：下一个超时时间能够被直接等待</li>
</ol>
<blockquote>
<div><p>(timeouts and intervals)
poll(..., int timeout)
kqueue(..., struct timespec * timeout)
epoll_wait(..., int timeout, ...)</p>
<p>timeout的精度是 毫秒， timespec 是纳秒。 但是两者都会按照系统时钟刻度去近似。</p>
<p>只能等待一个超时，所以 Node.js 会将所有的超时排序，并且每次都等待最近的一个。</p>
</div></blockquote>
<ol class="arabic simple" start="3">
<li>其他： 一定要在循环外部发生，并且完成时发送信号给循环。</li>
</ol>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id15">详情</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p class="first">不可轮询： 文件系统</p>
<p>所有的 fs.* 相关的，都会使用 uv 进程池（除非调用是同步的）。
这些阻塞调用是由单独一个进程调用的，当动作完成时，可读信号会被发送给循环，通过 eventfd 或者 self pipe。</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">self pipe :
一种管道，一端是由一个进程 或者 信号处理写入，另一端是循环读取。
如果等待的事件不能被直接的表示为一个文件句柄，传统的方式是叫醒事件循环。</p>
</div>
</li>
<li><p class="first">有时可轮询 : dns</p>
<ul class="simple">
<li><code class="code docutils literal"><span class="pre">dns.lookup()</span></code> 会调用 <code class="code docutils literal"><span class="pre">getaddrinfo()</span></code> , 这个函数会调用阻塞的套接字，素以不能够被集成到循环中。像 fs.* 一样，他是在进程池中被调用的。</li>
<li><code class="code docutils literal"><span class="pre">dns.&lt;everything</span> <span class="pre">else&gt;</span></code> 调用是非阻塞的，可以集成进循环，不是在进程池中执行的。</li>
</ul>
<p>这两者是有区别的，但是你现在可以知道，阻塞的库调用必须在进程池中调用，而DNS 查找等可以被集成到事件循环中。一定要清楚这些区别。</p>
</li>
<li><p class="first">可轮询: 信号</p>
<p>最终的异步 使用 self pipe 向循环中写入信号量标号。</p>
<p>请注意 监听信号 并不被推荐在事件循环中，因为他们有可能不会发生。</p>
</li>
<li><p class="first">可轮询 : 子进程</p>
<ul class="simple">
<li>Unix 子进程结束时会发出 SIGCHILD.</li>
<li>父子管道直接是可以轮询的</li>
</ul>
</li>
<li><p class="first">有时可轮询 :  C++ addons</p>
<p>插件应该使用 UV 的进程池 或者 和 循环集成，但是实际上他是可以做任何事情的，包括调用 阻塞循环的系统调用。</p>
<p>使用插件时要注意:</p>
<ul class="simple">
<li>审核插件代码</li>
<li>追踪循环指标</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="uv">
<h2><a class="toc-backref" href="#id16">关于 UV 进程池的重要信息</a><a class="headerlink" href="#uv" title="Permalink to this headline">¶</a></h2>
<p>他是被以下共享的：</p>
<blockquote>
<div><ul class="simple">
<li>fs</li>
<li>dns (only dns.lookup(), rest is fine)</li>
<li>crypto (only crypto.randomBytes() and crypto.pbkdf2())</li>
<li>http,get/request() (if called with a name, dns.lookup() is used)</li>
<li>any C++ addons that use it</li>
</ul>
</div></blockquote>
<p>默认情况下，进程数是 4， 大量使用以上功能的，需要扩大这个大小。</p>
<p>一些技巧:</p>
<ul class="simple">
<li>自行解析 DNS名称，避免调用 dns.lookup()</li>
<li>使用 UV_THREADPOOL_SIZE 扩大进程池大小</li>
</ul>
<p>你现在应该能够知道：</p>
<ul class="simple">
<li>什么是事件循环</li>
<li>什么时候 Node 是多进程的</li>
<li>为什么，它能够很好的扩展</li>
</ul>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Node_Profiling.html" class="btn btn-neutral float-right" title="Easy profiling for Node.js Applications" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Node_EventLoop.html" class="btn btn-neutral" title="The Node.js Event Loop, Timers, and process.nextTick()" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, BrianShen.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'Blog',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>